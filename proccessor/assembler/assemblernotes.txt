Let's break down each problem and explain how to solve it conceptually:

---

### **1. First Pass Doesn't Calculate Offsets**
**Problem**: The first pass isn’t simulating the layout of the program. All offsets stay at `0`, making labels/sections overlap incorrectly.  
**Solution**:  
- During the first pass, **simulate advancing the offset** for:  
  - Data directives (e.g., `.ascii` strings).  
  - Instructions (assume 4 bytes per ARM instruction).  
  - Alignment padding (e.g., after `.data` to align `.text`).  
- **Do not generate code** in the first pass—just track offsets for symbols.

---

### **2. `len = . - message` is Broken**
**Problem**: `len` resolves to `16` (padded size) instead of `14` (actual string length).  
**Solution**:  
- Calculate `len` **before** adding alignment padding.  
  - When parsing `len = . - message`, use the current offset *before padding* as the value.  
- Store `len` as a label with the correct value (`14`), not the padded offset.

---

### **3. Section Handling is Incorrect**
**Problem**: `.data` and `.text` both start at offset `0`.  
**Solution**:  
- Track the **end of each section** during the first pass.  
  - Example: After `.data` ends at offset 14, add 2 bytes of padding.  
  - `.text` should start at offset 16 (aligned to 16 bytes).  
- Update `Section` metadata:  
  - `.data`: `startOffset=0`, `size=16` (14 bytes data + 2 padding).  
  - `.text`: `startOffset=16`.

---

### **4. Padding Affects `len`**
**Problem**: Padding is added to `.ascii` *after* `len` is calculated.  
**Solution**:  
- Process the `.ascii` string.  
- Calculate `len = . - message` **immediately after the string**.  
- Add padding to align the next section.  

---

### **5. Label Metadata is Invalid**
**Problem**: `_start` (a code label) has `.data` content.  
**Solution**:  
- **Separate data and code labels**:  
  - Labels in `.data` (e.g., `message`) store data bytes.  
  - Labels in `.text` (e.g., `_start`) track code offsets.  
- Set `_start.offset` to the start of `.text` (offset 16), not `0`.

---

### **6. Instruction Processing is Incomplete**
**Problem**: Instructions like `mov` don’t affect offsets correctly.  
**Solution**:  
- In the first pass, **simulate instruction sizes**:  
  - For every instruction (e.g., `mov`, `ldr`), increment `offset` by `4` bytes.  
- In the second pass, generate machine code (optional but recommended for correctness).

---

### **7. Global Label Handling**
**Problem**: `.global _start` assigns `offset=0` instead of the `.text` start.  
**Solution**:  
- When processing `.global`, link the label to its **actual section offset**:  
  - During the first pass, `_start` should resolve to `.text`’s start offset (16).  
- Ensure labels are marked as global *after* their offsets are calculated.

---

### **Key Workflow Fixes**
1. **First Pass**:
   - Simulate advancing `offset` for all data/instructions.  
   - Track section offsets and alignment.  
   - Resolve symbol addresses (e.g., `message`, `len`, `_start`).  

2. **Second Pass**:
   - Generate machine code (encode instructions).  
   - Apply padding where needed.  
   - Finalize label metadata with correct offsets/sizes.  

3. **Testing**:
   - Verify `message` starts at `0`, `len=14`, `.text` starts at `16`.  
   - Check that `_start` points to the first instruction in `.text`.

By addressing these issues systematically, your assembler will correctly handle alignment, symbol resolution, and section layout.
